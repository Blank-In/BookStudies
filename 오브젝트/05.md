# 05: 책임 할당하기 <sup>133p</sup>

## 01: 책임 주도 설계를 향해 <sup>134p</sup>

- 데이터보다 행동을 먼저 결정하라
- 협력이라는 문맥 안에서 책임을 결정하라

### 데이터보다 행동을 먼저 결정하라 <sup>134p</sup>

_DB가 먼저 있는 기능의 경우 데이터 초점을 맞추는 경우가 많아왔다.\
행동을 먼저 결정할 수 있도록 많이 고민하자_

### 협력이라는 문맥 안에서 책임을 결정하라 <sup>135p</sup>

> 책임은 객체의 입장이 아니라 객체가 참여하는 협력에 적합해야 한다.\
> .....\
> 객체가 메시지를 선택하는 것이 아니라 메시지가 객체를 선택하게 해야 한다.

### 책임 주도 설계 <sup>136p</sup>

## 02: 책임 할당을 위한 GRASP 패턴 <sup>137p</sup>

Genral Responsibility Assignment Software Pattern (일반적인 책임 할당을 위한 소프트웨어 패턴)

### 정보 전문가에게 책임을 할당하라 <sup>138p</sup>

#### INFORMATION EXPERT 패턴 <sup>139p</sup>

_여기에서 데이터는 순수한 값을 뜻하고, 정보는 데이터의 조합이나 특정 조건을 만족하는지 등을 뜻하는 것 같다._

_객체에게 책임을 할당하려는 과정에서 동작에 필요한 데이터를 누가 가지고 있는지 생각하다보니\
여러 객체가 가지고 있는 데이터의 조합이 필요한 순간에 어떤 객체가 책임을 가져야할지 결정하기 어려웠음\
책임을 지는 객체가 필요한 정보를 알고 있는 다른 객체가 누구인지 알고 있는것에 설득력이 있다면 적절한 설계일 것 같다._

_최근 고민한 특정 동작 내부에서 특정 일자의 수동 확정 여부 판단: 서비스 -> 상품 -> 매장 의 방향으로 책임을 할당하고\
서비스가 상품에게 어떤 매장인지 전달하는 것이 좋아보인다._

### 높은 응집도와 낮은 결합도 <sup>142p</sup>

> 설계는 트레이드오프 활동이라는 것을 기억하라.\
> 동일한 기능을 구현할 수 있는 무수히 많은 설계가 존재한다.

_코드에 정답은 없지만 100점을 향하여-_

## 03: 구현을 통한 검증 <sup>146p</sup>

### DiscountCondition 개선하기 <sup>151p</sup>

- 응집도가 낮은 클래스는 하나 이상의 변경 이유를 가진다.
- 응집도가 낮은 클래스는 객체의 생성시에 일부 속성이 초기화되지 않는다.\
_setter를 통해 초기화(변경)가 외부에서 제어되는 속성이 일반적일 것 같다._
- 응집도가 낮은 클래스는 메서드가 사용하는 속성에 따라 그룹이 나뉜다. (모든 메서드가 객체의 모든 속성을 사용해야한다)

### 다형성을 통해 분리하기 <sup>156p</sup>

> #### POLYMORPHISM(다형성) 패턴 <sup>158p</sup>
> 객체의 타입에 따라 변하는 로직을 if ~ else 또는 switch ~ case 등의 조건 논리를 사용해서 설계한다면 새로운 변화가 일어난 경우 조건 논리를 수정해야한다.\
> 이것은 프로그램을 수정하기 어렵고 변경에 취약하게 만든다.

### 변경으로부터 보호하기 <sup>158p</sup>

> #### PROTECTED VARIATIONS(변경 보호) 패턴 <sup>159p</sup>

_이 패턴들을 적용할 수 있는 예시가 서비스에 다수 있을 것 같다.\
(MovieType - Movie.caculateMovieFee()와 유사한 매장용 앱 내에서 예약금 정률 환불과 정액 환불)\
적용하는 과정에서 발생하는 트레이드오프로 DB를 해석하는 객체가 하는일이 많아질 수 있을 것 같다._

### 변경과 유연성 <sup>163p</sup>

> #### 코드의 구조가 도메인 구조에 대한 새로운 통찰력을 제공한다. <sup>165p</sup>
> 도메인 모델은 단순히 도메인의 개념과 관계를 모아 놓은 것이 아니다.\
> 도메인 모델은 구현과 밀접한 관계를 맺어야 한다.\
> 도메인 모델은 코드에 대한 가이드를 제공할 수 있어야 하며 코드의 변화에 발맞춰 함께 변화해야 한다.

## 04: 책임 주도 설계의 대안 <sup>166p</sup>

_처음부터 코드를 잘 작성하기 위함이 이 책에서 설명하는 설계의 목적인 줄 알았으나,\
일단 기능을 만들고 코드를 **개선(리팩터링)** 하는 것도 책에서 추천하고 있다.\
훌륭한 객체지향 설계에 도달하기 위한 코드 작성 시작을 두려워하지 말자..._

### 메서드 응집도 <sup>166p</sup>

> 응집도가 낮은 메서드는 로직의 흐름을 이해하기 위해 주석이 필요한 경우가 대부분이다.\
> 메서드가 명령문들의 그룹으로 구성되고 각 그룹에 주석을 달아야 할 필요가 있다면 그 메서드의 응집도는 낮은 것이다. <sup>168p</sup>

_종종 이런 주석을 작성한 경우가 있었다..._

> 사람들은 때때로 나에게 한 메서드의 길이가 어느 정도 돼야 할지를 묻는다.\
> 그러나 나는 길이가 중요하다고 생각하지 않는다.\
> 중요한 것은 메서드의 이름과 메서드 몸체의 의미적 차이다. <sup>169p</sup>

_리팩터링을 다루는 다른 서적에서는 메서드는 n줄 이하를 권장하는 경우가 있었지만,\
해당 서적에서는 높은 응집도와 명확한 이름 정도로 권장하고 있다.\
저마다의 이유와 목표가 있기에 각 클래스에게 맞는 타협점을 목표로 하자._
