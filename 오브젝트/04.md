# 04: 설계 품질과 트레이드오프 <sup>97p</sup>

## 데이터 중심의 예매 시스템 <sup>98p</sup>

### 데이터를 준비하자 <sup>99p</sup>

```kotlin
public class Movie {
  val title: Stiring
  val runngingTime: Duration
  val fee: Duration
  val discountConditions: List<DiscountCondition>

  val movieType: MovieType
  val discountAmount: Money? // 정액 환불!
  val discountPercent: Double? // 정률 환불!
}
```

_매일 보는 것 같은 구조의 클래스다.\
앞의 설명을 보다 코드를 보자 **책임 중심 설계**와 **데이터(상태) 중심 설계**의 차이를 명확하게 알았다._

_DB 테이블의 설계가 변경 없이 객체에 바로 적용되는 것이 이런 현상을 더 자주 만드는 것 같다.\
객체에 적용되어도 괜찮은 설계를 가진 테이블 설계를 목표하는 것과, 테이블의 설계와 객체의 설계를 독립적으로 가져갈 수 있는 구조가 좋을까\
전자라면 환불 정책을 표현할 때 할인 정책의 종류를 나타내는 ENUM 컬럼이 추가되고 다른 컬럼에는 정수와 실수가 섞여 들어가는 상황이 생길 수 있다.\
후자라면 특정 객체를 저장할 때 둘 이상의 테이블을 변경하는 상황, 둘 이상의 객체가 하나의 테이블을 변경하는 상황등이 생길 수 있다._

_DB 테이블과 객체의 설계를 독립적으로 가져가는 것이 좋을 것 같다.\
테이블의 해석을 책임지는 객체(Entity)와 애플리케이션에서 역할을 가진 객체가 적절히 협력하도록 하여 예시와 같은 문제 상황이 발생하지 않도록 하는 것이 좋지 않을까_

## 설계 트레이드오프 <sup>108p</sup>

### 캡슐화 <sup>108p</sup>

> 변경될 가능성이 높은 부분을 **구현**이라고 부르고 상대적으로 안정적인 부분을 **인터페이스**라고 부른다는 사실을 기억하라.
> .....
> 캡슐화는 외부에서 알 필요가 없는 부분을 감춤으로써 대상을 단순화하는 추상화의 한 종류다.

### 응집도와 결합도 <sup>110</sup>
