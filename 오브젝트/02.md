# 02: 객체지향 프로그래밍

## 자율적인 객체

객체는 스스로 판단하고 행동하는 자율적인 존재\
접근제어자를 활용해 캡슐화 하자

## 객체지향 프로그래밍을 향해

### 협력하는 객체들의 공동체

객체는 다른 객체의 인터페이스에 공개된 행동을 수행하도록 요청할 수 있다.\
요청을 받은 객체는 자율적인 방법에 따라 요청을 처리한 후 응답한다.

객체가 다른 객체와 상호작용할 수 있는 유일한 방법은 메시지를 전송하는 것 뿐이다.\
다른 객체에게 요청이 도착할 때 해당 객체가 메시지를 수신했다고 이야기 한다.

## 상속과 다형성

### 컴파일 시간 의존성과 실행 시간 의존성

클래스 간의 의존성(코드의 의존성)과 객체 간의 의존성(실행 시점의 의존성) 사이의 차이가 클수록, 코드는 무슨 일을 하는지 파악하기 어려워진다.\
객체를 생성하고 연결하는 부분을 별도로 찾아야 하기 때문, 하지만 그만큼 코드는 유연해지고 확장하기 쉽게 된다.\

_이 정도 상속 규모(DiscountPolicy - AmountDiscountPolicy, PercentDiscountPolicy)는 문제 없고 오히려 더 이해하기 쉽다.\
어느 정도의 규모로 커지면 실패한 트레이드 오프일까_

### 차이에 의한 프로그래밍

### 다형성

### 인터페이스와 다형성

## 추상화와 유연성

### 추상 클래스와 인터페이스 트레이드오프

_극단적으로 추상화된 추상 클래스가 있고 (해당 클래스만 보았을 때 무슨 역할인지 알기 어려운 정도)\
이를 구현하는 클래스가 50개 정도 된다면 이 추상 클래스에 의존중인 클래스들은 이해는 물론이고 오히려 변경이 더욱 어렵지 않을까_

### 상속

_클래스의 상속 관계가 몇중까지 이어가면 역효과일까\
조부모 클래스, 부모 클래스, 자식 클래스 의 3단계 정도가 일반적인 상황에서 효과적으로 쓸 수 있는 한계가 아닐까 싶다_
```
class 단편모생물
class 오바조아: 단편모생물()
class 동물계: 오바조아()
class 척삭동물문: 동물계()
class 포유강: 척삭동물문()
class 영장목: 포유강()
class 사람과: 영장목()
class 사람속: 사람과()
class 사람: 사람속()
```

### 합성

_NoneDiscountPolicy는 적절한 선택인가? (A에게 데스크탑이, B에게 스마트폰이 있지만, C에게는 없음이라는 무언가가 있는 것처럼 느껴질 수 있다)\
Movie의 입장에서 할인 정책이 없다는 것을 알아야 한다면 (이 가정 자체는 객체지향적이지 않지만) NoneDiscountPolicy에 대한 의존성이 생기게 된다.\
하지만 할인 정책이 없는 상태에도 할인율 계산 외의 다른 책임이 생기거나 변경가능성이 생긴다면 NoneDiscountPolicy는 매우 적절한 설계이다_
