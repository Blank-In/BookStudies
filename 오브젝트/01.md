# 01: 객체, 설계 <sup>7p</sup>

## 01: 티켓 판매 애플리케이션 구현하기 <sup>9p</sup>

> .....

## 02: 무엇이 문제인가 <sup>14p</sup>

### 예상을 빗나가는 코드 <sup>15p</sup>

Theater 클래스의 enter 메서드가 수행하는 일
> 소극장은 관람객의 가방에 초대장이 있는지 확인한다.\
> 만약 초대장이 있다면 판매원의 매표소에 있는 티켓을 관람객의 가방으로 옮긴다.\
> 만약 없다면 관람객의 가방에서 티켓의 금액 만큼의 현금을 꺼내어 판매원의 매표소로 옮기고, 매표소에서 티켓을 관람객의 가방으로 옮긴다.

- 소극장외의 객체들은 소극장의 통제를 받는 수동적인 존재인 상태이다.
- 이 코드를 이해하기 위해선 모든 클래스의 내용들을 한번에 기억하고 있어야 한다.
- 변경에 취약해진다, Theater 클래스가 너무 많은 의존을 가지고 있어 수정이 어려워진다.

## 03: 설계 개선하기 <sup>17p</sup>

- 자율성을 높이자 <sup>18p</sup>
- 캡슐화와 응집도 <sup>25p</sup>
- 절차지향과 객체지향 <sup>26p</sup>
- 책임의 이동 <sup>27p</sup>

_직관적으로 "보기 좋다"라고 느꼈던 작업들이 명확한 이름으로 정리되면서, 왜 그렇게 느꼈는지 이해할 수 있었고, 그것이 왜 중요한지도 분명해졌다._

### 그래, 거짓말이다! <sup>33p</sup>

_객체의 자율성?\
현실에서 Theater, Bag, TicketOffice 는 자율적인 존재가 아니다.\
주인이 가방에게 요청하지않고, 매표소는 스스로 행동할 수 없다._

의인화: 현실에서 수동적인 존재라하더라도 객체지향의 세계에서는 능동적이고 자율적인 존재가 된다.

_그렇다면 현실에서 인간의 역할을 하는 객체들만이 책임을 가져 현실과 유사하게 동작하도록 만든다면, 좋은 설계가 될까?\
: 직관적으로 이해하기는 쉬울 수 있지만, 변경에 취약해지고 규모가 커질수록 특정 객체에 책임이 집중되어 오히려 전체 구조를 이해하기 어려워질 수 있다._

## 04: 객체지향 설계 <sup>34p</sup>

협력하는 객체 사이의 의존성을 적절하게 관리하는 설계

_만약 모든 처리를 이벤트 발행과 수신만으로 수행해, 의존성을 거의 0에 가깝게 만든다면, 그 설계는 어떤 결과를 가져오게 될까?_
