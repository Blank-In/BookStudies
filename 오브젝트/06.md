# 06: 메시지와 인터페이스 <sup>175p</sup>

## 01: 협력과 메시지 <sup>176p</sup>

### 메시지와 메시지 전송 <sup>177p</sup>

> 한 객체가 다른 객체에게 도움을 요청하는 것을 **메시지 전송(sending)** 또는 **메시지 패싱(passing)** 이라고 부른다.\
> 메시지를 전송하는 객체를 **메시지 전송자(sender)** 라고 부르고 메시지를 수신하는 객체를 **메시지 수신자(receiver)** 라고 부른다.

> 메시지는 **오퍼레이션명(operation name)** 과 **인자(argument)** 로 구성되며 메시지 전송은 여기에 메시지 수신자를 추가한 것이다.

### 메시지와 메서드 <sup>178p</sup>

> 메시지를 수신했을 때 실제로 실행되는 함수 또는 프로시저를 **메서드**라고 부른다

### 퍼블릭 인터페이스와 오퍼레이션 <sup>179p</sup>

> 객체가 의사소통을 위해 외부에 공개하는 메시지의 집합을 **퍼블릭 인터페이스**라고 부른다.\
> 퍼블릭 인터페이스에 포함된 메시지를 **오퍼레이션** 이라고 부른다.

### 시그니처 <sup>180p</sup>

> 오퍼레이션(메서드)의 이름과 파라미터 목록을 함쳐 **시그니처** 라고 부른다.

## 02: 인터페이스와 설계 품질 <sup>181p</sup>

### 디미터 법칙 <sup>182p</sup>

_제약을 적용하는 것이 낮은 결합도로 즉시 이어지게 되어 적용하기 간단한 방법인 것 같다.\
코드를 작성하면서 응집도에 유의하지 않으면 작업량과 잘못된 책임의 메서드가 늘어나 제약이 잘 기능하지 않을 수 있을 것 같다._

> 무비판적으로 디미터 법칙을 수용하면 퍼블릭 인터페이스 관점에서 객체의 응집도가 낮아질 수도 있다. <sup>186p</sup>

### 묻지 말고 시켜라 <sup>186p</sup>

### 의도를 드러내는 인터페이스 <sup>188p</sup>

> 메서드의 이름을 짓는 두번째 방법은 '어떻게'가 아니라 '무엇'을 하는지를 드러내는 것이다.

_고민없이 바로 이름을 짓는 경우에 어떻게가 드러나는 경우가 많아왔다._

> 매우 다른 두번째 구현을 상상하라. 그러고는 해당 메서드에 동일한 이름을 붙인다고 상상해보라.\
> 그렇게 하면 아마도 그 순간에 여러분이 할 수 있는 한 가장 추상적인 이름을 메서드에 붙일 것이다. <sup>190p</sup>

## 03: 원칙의 함정 <sup>198p</sup>

이전 주제에서 짧게 설명한 위험성에 대해 상세히 설명하고 때로는 원칙을 무시하도록 권장하고 있다.

### 결합도와 응집도의 충돌 <sup>199p</sup>

> 디미터 법칙과 묻지 말고 시켜라 원칙을 무작정 따르면 애플리케이션은 응집도가 낮은 객체로 넘쳐날 것이다. <sup>200p</sup>

## 04: 명령-쿼리 분리 원칙 <sup>202p</sup>
