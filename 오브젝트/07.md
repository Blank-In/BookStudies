# 07: 객체 분해 <sup>216p</sup>

## 01: 프로시저 추상화와 데이터 추상화 <sup>217p</sup>

- 프로시저 추상화: 소프트웨어가 무엇을 해야 하는지를 추상화
  - 기능 분해(알고리즘 분해)
- 데이터 추상화: 소프트웨어가 무엇을 알아야 하는지를 추상화
  - 추상 데이터 타입: 데이터를 중심으로 타입을 추상화
  - 객체지향: 데이터를 중심으로 프로시저를 추상화

> 객체지향을 바라보는 일반적인 관점은 데이터 추상화와 프로시저 추상화를 함께 포함한 클래스를 이용해 시스템을 분해하는 것이다. <sup>218p</sup>

## 02: 프로시저 추상화와 기능 분해 <sup>219p</sup>

### 급여 관리 시스템 <sup>219p</sup>
### 급여 관리 시스템 구현 <sup>222p</sup>

하향식 접근법으로 급여 관리 시스템을 설계하고 실제 코드로 구현한다.

_하향식 접근법은 기능의 완성으로 이어지는 빠른 방법이지만 변경이 어려운 절차지향 설계로 이어지는 가장 일반적인 방법으로 보인다._

### 하향식 기능 분해의 문제점 <sup>225p</sup>

> ...하지만 불행하게도 소프트웨어는 항상 변경된다.

- 하나의 메인 함수라는 비현실적인 아이디어 <sup>226p</sup>
- 메인 함수의 빈번한 재설계 <sup>227p</sup>
  - _메인 함수는 아니지만 유사한 코드들이 존재하고 작성했던 적도 있다, 반성하자_
- 비즈니스 로직과 사용자 인터페이스의 결합 <sup>229p</sup>
  - _알림톡의 경우 템플릿의 형태에 따라 결합을 풀기 어려운 경우가 있었다. 이러한 코드들은 무슨일을 하는지 분석하는 과정이 더욱 어려웠던 것 같다._
  - _최근 작업중에서 알림톡 상세페이지의 경우 비즈니스 로직에서 특정 화면 영역의 노출 플래그를 계산하고, 화면에서 그 플래그를 그대로 쓰는 경우가 있고 데이터를 다시 해석하거나 플래그와 조합하는 경우들이 섞여있어서, 하나의 영역이 어떤 조건에서 노출되는지 확인하려면 사실상 비즈니스 로직을 매번 읽어봐야했다._
- 성급하게 결정된 실행 순서 <sup>229p</sup>
- 데이터 변경으로 인한 파급효과 <sup>231p</sup>
  - _ct-common에 위치한 모델이나 비즈니스 로직들의 변경시 예시보다 더 큰 효과로 어어지는 경우가 잦았던 문제이다._

### 언제 하향식 문해가 유용한가? <sup>234p</sup>

- 설계의 다양한 측면을 논리적으로 설명하고 문서화하기에 용이하다
- 작은 프로그램과 개별 알고리즘을 위해서는 유용한 패러다임으로 남아있다

## 03: 모듈 <sup>235p</sup>

### 정보 은닉과 모듈 <sup>235p</sup>

모듈은 다음과 같은 두 가지 비밀을 감춰야 한다.

- 복잡성: 모듈이 너무 복잡한 경우 이해하고 사용하기 어렵다.
- 변경 가능성: 변경 가능한 설계 결정이 외부에 노출될 경우 실제로 변경이 발생했을 때 파급효과가 커진다.

> 자바에서 모듈의 개념은 패키지(package)를 이용해 구현할 수 있다. <sup>237p</sup>

_객체는 추상화된 사물/개념이고, 모듈은 클래스까지 포함하는 하나의 관심사 집합으로 묶어두는 것을 말하는 것 같다._

### 모듈의 장점과 한계 <sup>239p</sup>

- 모듈 내부의 변수가 변경되더라도 모듈 내부에만 영향을 미친다
  - _정말 중요한 것 같다. 노출된 정보를 담고있는 코드를 수정할 때에 IDE에서 알려줄 수 있는 영향 범위도 주의하게 되는데, 사람이 파악해야 하는 외부나 서비스 전까지 파악이 불가한 지점이 있다면 너무 두려워진다._
- 비즈니스 로직과 사용자 인터페이스에 대한 관심사를 분리한다.
- 전역 변수와 전역 함수를 제거함으로써 네임스페이스 오염을 방지한다.

> 기능이 아니라 데이터를 중심으로 시스템을 분해하는것이다. 모듈은 데이터와 함수가 통합된 한 차원 높은 추상화를 제공하는 설계 단위다. <sup>240p</sup>

## 04: 데이터 추상화와 추상 데이터 타입 <sup>240p</sup>

> 추상 데이터 타입으로 표현된 데이터를 이용해서 기능을 구현하는 핵심 로직은 추상 데이터 타입 외부에 존재한다.\
> 추상 데이터 타입은 데이터에 대한 관점을 설계의 표면으로 끌어올리기는 하지만 여전히 데이터와 기능을 분리하는 절차적인 설계의 틀에 갇혀 있는 것이다. <sup>244p</sup>

_추상 데이터 타입은 인터페이스 개념이 없는 클래스 수준의 추상화로 보인다.\
부족한 설계의 객체는 추상 데이터와 큰 차이가 없는 것 같다._

## 05: 클래스 <sup>245p</sup>

### 클래스는 추상 데이터 타입인가? <sup>245p</sup>

> 상속과 다형성을 지원하지 않는 추상 데이터 타입 기반의 프로그래밍 패러다임을 객체지반 프로그래밍(Object-Based Programming) 이라고 부르기도 한다.

타입 추상화는 오퍼레이션을 기준으로 타입을 추상화한다. 클래스는 타입을 기준으로 절차들을 추상화한다. <sup>247p</sup>

정규 직원과 아르바이트 직원의 calculatePay, mothlyBaseDay 는 다르게 동작하지만 하나의 타입으로 묶여있다.

### 변경을 기준으로 선택해라 <sup>250p</sup>

> 추상 데이터 타입으로 구현된 Employee 클래스를 살펴보면 hourly라는 인스턴스 변수에 직원의 유형을 저장한다는 것을 알 수 있다. 이처럼 인스턴스 변수에 저장된 값을 기반으로 메서드 내에서 타입을 명시적으로 구분하는 방식은 객체지향을 위반하는 것으로 간주된다.

_Reservation의 reservationStatus(생성, 수정, 취소)이나 awaitingLevel은 추상화의 기준이 되어야 하는걸까? 자칫하면 불필요한 작업이 될 수 있을 것 같다. 이 제안은 어느정도 타협할 필요가 있어보인다._

> 설계의 유용성은 변경의 방향성과 발생 빈도에 따라 결정된다. <sup>251p</sup>

_추상 데이터 타입도 선택지가 될 수 있음을 알려주고 있다. 이전 페이지에서의 걱정이 해소되었다._

> 변경의 축을 찾아라. 객체지향적인 접근법이 모든 경우에 올바른 해결 방법인 것은 아니다. <sup>252p</sup>

### 협력이 중요하다 <sup>252p</sup>

객체들의 협력하는 방식에 집중해야 함을 다시 설명하고 있다.
