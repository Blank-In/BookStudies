# 들어가며: 프로그래밍 패러다임

현대에 패러다임은 '한 시대의 사회 전체가 공유하는 이론이나 방법, 문제의식 등의 체계'라는 의미로 사용되고 있다.\
과학혁명이란 과거의 패러다임이 새로운 패러다임에 의해 대체됨을 뜻한다. 이를 '패러다임 전환'이라고 부른다.

프로그래밍 패러다임은 기존의 패러다임을 폐기하는 것이 아닌 단점을 보완하는 발전적 과정을 거치는 것으로 보인다.


# 01: 객체, 설계

## 예상을 빗나가는 코드

Theater 클래스의 enter 메서드가 수행하는 일
> 소극장은 관람객의 가방에 초대장이 있는지 확인한다.\
> 만약 초대장이 있다면 판매원의 매표소에 있는 티켓을 관람객의 가방으로 옮긴다.\
> 만약 없다면 관람객의 가방에서 티켓의 금액 만큼의 현금을 꺼내어 판매원의 매표소로 옮기고, 매표소에서 티켓을 관람객의 가방으로 옮긴다.

- 소극장외의 객체들은 소극장의 통제를 받는 수동적인 존재인 상태이다.
- 이 코드를 이해하기 위해선 모든 클래스의 내용들을 한번에 기억하고 있어야 한다.
- 변경에 취약해진다, Theater 클래스가 너무 많은 의존을 가지고 있어 수정이 어려워진다.

## 설계 개선하기

- 자율성을 높이자
- 캡슐화와 응집도
- 절차지향과 객체지향
- 책임의 이동

_직관적으로 "보기 좋다"라고 느꼈던 작업들이 명확한 이름으로 정리되면서, 왜 그렇게 느꼈는지 이해할 수 있었고, 그것이 왜 중요한지도 분명해졌다._

### 그래, 거짓말이다!

객체의 자율성?\
현실에서 Theater, Bag, TicketOffice 는 자율적인 존재가 아니다.\
주인이 가방에게 요청하지않고, 매표소는 스스로 행동할 수 없다.\
의인화: 현실에서 수동적인 존재라하더라도 객체지향의 세계에서는 능동적이고 자율적인 존재가 된다.

_그렇다면 현실에서 인간의 역할을 하는 객체들만이 책임을 가져 현실과 유사하게 동작하도록 만든다면, 좋은 설계가 될까?\
: 직관적으로 이해하기는 쉬울 수 있지만, 변경에 취약해지고 규모가 커질수록 특정 객체에 책임이 집중되어 오히려 전체 구조를 이해하기 어려워질 수 있다._

## 객체지향 설계
협력하는 객체 사이의 의존성을 적절하게 관리하는 설계

_만약 모든 처리를 이벤트 발행과 수신만으로 수행해, 의존성을 거의 0에 가깝게 만든다면, 그 설계는 어떤 결과를 가져오게 될까?_


# 02: 객체지향 프로그래밍

주요 키워드: 협력, 자율성, 트레이드오프\
클래스 사이의 의존성(코드의 의존성)과 객체의 의존성(실행 시점의 의존성)에 차이가 생길수록 코드는 이해하기 어려워{무슨일을 하는지 완벽히 파악할 수 없다?} 진다(객체를 생성하고 연결하는 부분을 찾아야함)\
반면에 코드는 더 유연해지고 확장가능해진다 {변경이 쉽다}

이 정도 상속 규모(DiscountPolicy - Amount..., Percent...) 는 아무런 문제 없고 오히려 더 이해하기 쉬울 수 있는데\
어느 정도의 규모로 커지면 실패한 트레이드 오프일까\
{극단적으로 추상화된 추상 클래스가 있고(이 클래스만 보았을 때 무슨 역할인지 알 수 없는 정도?) 구현하는 클래스가 50개 정도 된다면 이 추상 클래스에 의존중인 클래스들은 이해는 물론이고 오히려 변경이 더욱 어렵지 않을까} 

(자식클래스와 부모클래스) 상속 관계가 몇중까지 내려가면 역효과일까\
```
class 단편모생물
class 오바조아: 단편모생물()
class 동물계: 오바조아()
class 척삭동물문: 동물계()
class 포유강: 척삭동물문()
class 영장목: 포유강()
class 사람과: 영장목()
class 사람속: 사람과()
class 사람: 사람속()
```
{조부모 클래스, 부모 클래스, 자식 클래스 의 3단계 정도 까지가 효과적으로 쓸 수 있는 한계가 아닐까?}


NoneDiscountPolicy 는 적절한가? (A에게는 이 있고, B에게는 데스크탑이 있지만 C에게는 없음이 있다??)
Movie의 입장에서 할인 정책이 없다는 것을 알아야하게 된다면{이 조건이 객체지향적이지는 않은 것 같다} NoneDiscountPolicy 까지 알아야(의존성이 늘어나는) 된다.
DiscountPolicy 가 없음에 할인율 계산(0원) 외에 다른 책임이 생기거나 변경이 될 수 있다면 유효한 것 같다
kotlin 이었다면? discountPolicy?.calculateDiscountAmount(...)
