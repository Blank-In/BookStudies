# 들어가며: 프로그래밍 패러다임

현대에 패러다임은 '한 시대의 사회 전체가 공유하는 이론이나 방법, 문제의식 등의 체계'라는 의미로 사용되고 있다.\
과학혁명이란 과거의 패러다임이 새로운 패러다임에 의해 대체됨을 뜻한다. 이를 '패러다임 전환'이라고 부른다.

프로그래밍 패러다임은 기존의 패러다임을 폐기하는 것이 아닌 단점을 보완하는 발전적 과정을 거치는 것으로 보인다.


# 01: 객체, 설계

## 예상을 빗나가는 코드

Theater 클래스의 enter 메서드가 수행하는 일
> 소극장은 관람객의 가방에 초대장이 있는지 확인한다.\
> 만약 초대장이 있다면 판매원의 매표소에 있는 티켓을 관람객의 가방으로 옮긴다.\
> 만약 없다면 관람객의 가방에서 티켓의 금액 만큼의 현금을 꺼내어 판매원의 매표소로 옮기고, 매표소에서 티켓을 관람객의 가방으로 옮긴다.

- 소극장외의 객체들은 소극장의 통제를 받는 수동적인 존재인 상태이다.
- 이 코드를 이해하기 위해선 모든 클래스의 내용들을 한번에 기억하고 있어야 한다.
- 변경에 취약해진다, Theater 클래스가 너무 많은 의존을 가지고 있어 수정이 어려워진다.

## 설계 개선하기

- 자율성을 높이자
- 캡슐화와 응집도
- 절차지향과 객체지향
- 책임의 이동

_직관적으로 "보기 좋다"라고 느꼈던 작업들이 명확한 이름으로 정리되면서, 왜 그렇게 느꼈는지 이해할 수 있었고, 그것이 왜 중요한지도 분명해졌다._

### 그래, 거짓말이다!

객체의 자율성?\
현실에서 Theater, Bag, TicketOffice 는 자율적인 존재가 아니다.\
주인이 가방에게 요청하지않고, 매표소는 스스로 행동할 수 없다.\
의인화: 현실에서 수동적인 존재라하더라도 객체지향의 세계에서는 능동적이고 자율적인 존재가 된다.

_그렇다면 현실에서 인간의 역할을 하는 객체들만이 책임을 가져 현실과 유사하게 동작하도록 만든다면, 좋은 설계가 될까?\
: 직관적으로 이해하기는 쉬울 수 있지만, 변경에 취약해지고 규모가 커질수록 특정 객체에 책임이 집중되어 오히려 전체 구조를 이해하기 어려워질 수 있다._

## 객체지향 설계

협력하는 객체 사이의 의존성을 적절하게 관리하는 설계

_만약 모든 처리를 이벤트 발행과 수신만으로 수행해, 의존성을 거의 0에 가깝게 만든다면, 그 설계는 어떤 결과를 가져오게 될까?_


# 02: 객체지향 프로그래밍

## 자율적인 객체

객체는 스스로 판단하고 행동하는 자율적인 존재\
접근제어자를 활용해 캡슐화 하자

## 객체지향 프로그래밍을 향해

### 협력하는 객체들의 공동체

객체는 다른 객체의 인터페이스에 공개된 행동을 수행하도록 요청할 수 있다.\
요청을 받은 객체는 자율적인 방법에 따라 요청을 처리한 후 응답한다.

객체가 다른 객체와 상호작용할 수 있는 유일한 방법은 메시지를 전송하는 것 뿐이다.\
다른 객체에게 요청이 도착할 때 해당 객체가 메시지를 수신했다고 이야기 한다.

## 상속과 다형성

### 컴파일 시간 의존성과 실행 시간 의존성

클래스 간의 의존성(코드의 의존성)과 객체 간의 의존성(실행 시점의 의존성) 사이의 차이가 클수록, 코드는 무슨 일을 하는지 파악하기 어려워진다.\
객체를 생성하고 연결하는 부분을 별도로 찾아야 하기 때문, 하지만 그만큼 코드는 유연해지고 확장하기 쉽게 된다.\

_이 정도 상속 규모(DiscountPolicy - AmountDiscountPolicy, PercentDiscountPolicy)는 문제 없고 오히려 더 이해하기 쉽다.\
어느 정도의 규모로 커지면 실패한 트레이드 오프일까_

### 차이에 의한 프로그래밍

### 다형성

### 인터페이스와 다형성

## 추상화와 유연성

### 추상 클래스와 인터페이스 트레이드오프

_극단적으로 추상화된 추상 클래스가 있고 (해당 클래스만 보았을 때 무슨 역할인지 알기 어려운 정도)\
이를 구현하는 클래스가 50개 정도 된다면 이 추상 클래스에 의존중인 클래스들은 이해는 물론이고 오히려 변경이 더욱 어렵지 않을까_

### 상속

_클래스의 상속 관계가 몇중까지 이어가면 역효과일까\
조부모 클래스, 부모 클래스, 자식 클래스 의 3단계 정도가 일반적인 상황에서 효과적으로 쓸 수 있는 한계가 아닐까 싶다_
```
class 단편모생물
class 오바조아: 단편모생물()
class 동물계: 오바조아()
class 척삭동물문: 동물계()
class 포유강: 척삭동물문()
class 영장목: 포유강()
class 사람과: 영장목()
class 사람속: 사람과()
class 사람: 사람속()
```

### 합성

_NoneDiscountPolicy는 적절한 선택인가? (A에게 데스크탑이, B에게 스마트폰이 있지만, C에게는 없음이라는 무언가가 있는 것처럼 느껴질 수 있다)\
Movie의 입장에서 할인 정책이 없다는 것을 알아야 한다면 (이 가정 자체는 객체지향적이지 않지만) NoneDiscountPolicy에 대한 의존성이 생기게 된다.\
하지만 할인 정책이 없는 상태에도 할인율 계산 외의 다른 책임이 생기거나 변경가능성이 생긴다면 NoneDiscountPolicy는 매우 적절한 설계이다_
